import numpy as np
import pandas as pd
import math
import time
from io import StringIO
import pickle

import aamaths as aam
import lst as lst

import datetime

moon_coef_47a = pd.read_csv('coefs/moon_coef_47a.csv')
moon_coef_47b = pd.read_csv('coefs/moon_coef_47b.csv')
earth_coef_b0 = pd.read_csv('coefs/earth_coef_b0.csv')
earth_coef_b1 = pd.read_csv('coefs/earth_coef_b1.csv')

moon_crescent_data = [[50, 100000, 50000], [45, 6, 2.949], [40, 3, 1.396], [35, 2.05, 0.865], [30, 1.65, 0.615], [25, 1.425, 0.453], [20, 1.29, 0.337], [
    15, 1.209, 0.251], [10, 1.156, 0.178], [5, 1.125, 0.118], [4, 1.1206, 0.10694], [3, 1.1165, 0.095619], [2, 1.1126, 0.083485], [1, 1.1091, 0.070892], [0, 1.105, 0.052]]


def illuminated_fraction(moon_beta, moon_lambda, sun_lambda):

    # Get the elongation
    A = np.cos(np.deg2rad(moon_beta)) * \
        np.cos(np.deg2rad(moon_lambda) - np.deg2rad(sun_lambda))
    psi = 90 - np.rad2deg(np.arctan(A / np.sqrt(1 - A*A)))

    # Phase angle
    X = 152.04e9 * np.sin(np.deg2rad(psi))
    Y = 384.4e6 - (152.04e9 * A)
    Il = np.arctan2(X, Y)

    # Illuminated fraction
    K = (1 + np.cos(Il)) / 2

    return K


def Ld_deg(T):
    return aam.deg_wrap_360(218.3164477 + 481267.88123421*T - 0.0015786*pow(T, 2) + pow(T, 3)/538841 - pow(T, 4)/65194000)


def D_deg(T):
    return aam.deg_wrap_360(297.8501921 + 445267.1114034*T - 0.0018819*pow(T, 2) + pow(T, 3)/545868 - pow(T, 4)/113065000)


def Md_deg(T):
    return aam.deg_wrap_360(134.9633964 + 477198.8675055*T + 0.0087414*pow(T, 2) + pow(T, 3)/69699 - pow(T, 4)/14712000)


def F_deg(T):
    return aam.deg_wrap_360(93.2720950 + 483202.0175233*T - 0.0036539*pow(T, 2) - pow(T, 3)/3526000 + pow(T, 4)/863310000)


def M_deg(T):
    return aam.deg_wrap_360(357.5291092 + 35999.0502909*T - 0.0001536*pow(T, 2) + pow(T, 3)/24490000)


def moon_E(T):
    return 1 - 0.002516 * T - 0.0000074 * pow(T, 2)


def ecliptical_coords(dt):
    jd = lst.julian_day(dt)

    T = (jd - 2451545) / 36525

    Ld = np.deg2rad(Ld_deg(T))
    D = np.deg2rad(D_deg(T))
    Md = np.deg2rad(Md_deg(T))
    F = np.deg2rad(F_deg(T))
    M = np.deg2rad(M_deg(T))

    E = moon_E(T)

    A1 = np.deg2rad(aam.deg_wrap_360(119.75 + 131.849 * T))
    A2 = np.deg2rad(aam.deg_wrap_360(53.09 + 479264.290 * T))
    A3 = np.deg2rad(aam.deg_wrap_360(313.45 + 481266.484 * T))

    # Calculate the lambda
    sigma_l = 0
    for index, row in moon_coef_47a.iterrows():
        sigma_this = row.A * \
            np.sin((row.D * D) + (row.M * M) + (row.Md * Md) + (row.F * F))
        if row.M == 1 or row.M == -1:
            sigma_this *= E
        elif (row.M == 2 or row.M == -2):
            sigma_this *= (E * E)
        sigma_l += sigma_this
    sigma_l = sigma_l + (3958 * np.sin(A1)) + \
        (1962 * np.sin(Ld - F)) + (318 * np.sin(A2))
    moon_l = Ld_deg(T) + (sigma_l / 1e6)

    # Calculate the beta
    sigma_b = 0
    for index, row in moon_coef_47b.iterrows():
        sigma_this = row.A * \
            np.sin((row.D * D) + (row.M * M) + (row.Md * Md) + (row.F * F))
        if row.M == 1 or row.M == -1:
            sigma_this *= E
        elif (row.M == 2 or row.M == -2):
            sigma_this *= (E * E)
        sigma_b += sigma_this
    sigma_b = sigma_b - (2235 * np.sin(Ld)) + (382 * np.sin(A3)) + (175 * np.sin(A1 - F)) + \
        (175 * np.sin(A1 + F)) + (127 * np.sin(Ld - Md)) - (115 * np.sin(Ld + Md))
    moon_b = sigma_b / 1e6

    return [moon_b, moon_l]


def equatorial_coords(dt):
    b, l = ecliptical_coords(dt)
    return aam.ecliptical2equatorial(b, l)


def abs_bright_limb_angle(sun_dec, sun_ra, moon_dec, moon_ra):
    sun_dec = np.deg2rad(sun_dec)
    sun_ra = np.deg2rad(sun_ra)
    moon_dec = np.deg2rad(moon_dec)
    moon_ra = np.deg2rad(moon_ra)
    X = np.sin(sun_dec) * np.cos(moon_dec) - np.cos(sun_dec) * \
        np.sin(moon_dec) * np.cos(sun_ra - moon_ra)
    Y = np.cos(sun_dec) * np.sin(sun_ra - moon_ra)
    P1 = aam.deg_wrap_360(np.rad2deg(np.arctan2(Y, X)))
    return P1


def zenith_angle_offset(dt, timezone, observer_longitude, observer_latitude, moon_alpha, moon_delta):
    _lst = lst.local_sidereal_time(dt, timezone, observer_longitude)
    moon_hour_angle = aam.deg_wrap_360(_lst - moon_alpha)

    lat_r = np.deg2rad(observer_latitude)
    mha_r = np.deg2rad(moon_hour_angle)
    d_r = np.deg2rad(moon_delta)
    return np.rad2deg(np.arctan((np.sin(mha_r)) / ((np.tan(lat_r) * np.cos(d_r)) - (np.sin(d_r) * np.cos(mha_r)))))


def bright_limb_angle(sun_dec, sun_ra, moon_dec, moon_ra, dt, timezone, longitude, latitude):
    bl_angle_deg = abs_bright_limb_angle(sun_dec, sun_ra, moon_dec, moon_ra)
    zenith_angle = zenith_angle_offset(
        dt, timezone, longitude, latitude, moon_ra, moon_dec)

    if latitude < 0:
        zenith_angle += 180

    return aam.deg_wrap_360(360 - (bl_angle_deg - zenith_angle))


def crescent_diameter(lit_area):
    percentage = lit_area * 100
    df = pd.DataFrame(moon_crescent_data, columns=[
        "percentage", "diameter", "distance"])
    if percentage == 50:
        return df.iloc[0].diameter
    point0 = df[df['percentage'] <= percentage].sort_values(
        by='percentage').iloc[-1]
    point1 = df[df['percentage'] > percentage].sort_values(
        by='percentage').iloc[0]
    yp = aam.linear_interp(point0.percentage, point1.percentage,
                           point0.diameter, point1.diameter, percentage)
    return yp


def crecesent_distance(lit_area):
    percentage = lit_area * 100
    df = pd.DataFrame(moon_crescent_data, columns=[
        "percentage", "diameter", "distance"])
    if percentage == 50:
        return df.iloc[0].distance
    point0 = df[df['percentage'] <= percentage].sort_values(
        by='percentage').iloc[-1]
    point1 = df[df['percentage'] > percentage].sort_values(
        by='percentage').iloc[0]
    yp = aam.linear_interp(point0.percentage, point1.percentage,
                           point0.distance, point1.distance, percentage)
    return yp


def altitude(H, phi, dec):
    return np.arcsin((np.sin(phi) * np.sin(dec)) + (np.cos(phi) * np.cos(dec) * np.cos(H)))


def siderealTime(d, lw):
    return np.deg2rad(280.16 + 360.9856235 * d) - lw


def moon_altitude(dt, lat, lng):
    lw = np.deg2rad(-lng)
    phi = np.deg2rad(lat)
    d = (time.mktime(dt.timetuple()) * 1000) / \
        86400000 - 0.5 + 2440588 - 2451545
    ra, dec = equatorial_coords(dt)
    ra = np.deg2rad(ra)
    dec = np.deg2rad(dec)
    H = np.deg2rad(280.16 + 360.9856235 * d) - lw - ra
    h = altitude(H, phi, dec)
    h = h + np.deg2rad(0.017) / np.tan(h +
                                       np.deg2rad(10.26) / (h + np.deg2rad(5.10)))
    return h


def hoursLater(date, h):
    return date + datetime.timedelta(hours=h)


def moon_times(dt, lat, lng):
    t = dt.replace(hour=0, minute=0, second=0)

    rad = 3.141592653589793 / 180.0

    hc = rad * 0.133
    h0 = moon_altitude(t, lat, lng) - hc
    rise = 0
    sett = 0

    # go in 2-hour chunks, each time seeing if a 3-point quadratic curve crosses zero (which means rise or set)
    for i in range(1, 25, 2):
        h1 = moon_altitude(hoursLater(t, i), lat, lng) - hc
        h2 = moon_altitude(hoursLater(t, i + 1), lat, lng) - hc

        a = (h0 + h2) / 2 - h1
        b = (h2 - h0) / 2
        xe = -b / (2 * a)
        ye = (a * xe + b) * xe + h1
        d = b * b - 4 * a * h1
        roots = 0

        if d >= 0:
            dx = math.sqrt(d) / (abs(a) * 2)
            x1 = xe - dx
            x2 = xe + dx
            if abs(x1) <= 1:
                roots += 1
            if abs(x2) <= 1:
                roots += 1
            if x1 < -1:
                x1 = x2

        if roots == 1:
            if h0 < 0:
                rise = i + x1
            else:
                sett = i + x1

        elif roots == 2:
            rise = i + (x2 if ye < 0 else x1)
            sett = i + (x1 if ye < 0 else x2)

        if rise and sett:
            break

        h0 = h2

    if rise:
        rise = hoursLater(t, rise)
    else:
        rise = dt.replace(hour=0, minute=0, second=0)
    if sett:
        sett = hoursLater(t, sett)
    else:
        sett = dt.replace(hour=23, minute=59, second=59)

    return rise, sett
