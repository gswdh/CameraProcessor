import math
import numpy as np

def deg_wrap_360(deg):
    fResult = math.fmod(deg, 360)
    if fResult < 0:
        fResult += 360
    return fResult

def deg_wrap_9090(deg):
    fResult = deg_wrap_360(deg)
    if fResult > 270:
        fResult = fResult - 360
    elif fResult > 180:
        fResult = 180 - fResult
    elif (fResult > 90):
        fResult = 180 - fResult
    return fResult

def abs_floor(val):
    if val >= 0.0:
        return math.floor(val);
    else:
        return math.ceil(val);

def mod_day(hours):
    if hours < 0:
        hours += 24.0
    return hours % 24

def mod_2pi(angle):
    b = angle / 360.0
    a = 360.0 * (b - abs_floor(b))
    if a < 0:
        a = 360.0 + a
    return a

def sign(n):
    if n < 0:
        return False
    return True

def same_side(A, R):
    if (sign(np.cos(np.deg2rad(A))) == sign(np.cos(np.deg2rad(R)))) and (sign(np.sin(np.deg2rad(A))) == sign(np.sin(np.deg2rad(R)))):
        return (A + 36000) % 360
    else:
        return (A + 36180) % 360

def ecliptical2equatorial(B, L):
    e = 23.439168
    a = np.rad2deg(np.arctan(np.tan(np.deg2rad(L))*np.cos(np.deg2rad(e)) - np.tan(np.deg2rad(B))*np.sin(np.deg2rad(e))/np.cos(np.deg2rad(L))))
    d = np.rad2deg(np.arcsin(np.sin(np.deg2rad(B))*np.cos(np.deg2rad(e)) + np.cos(np.deg2rad(B))*np.sin(np.deg2rad(e))*np.sin(np.deg2rad(L))))
    a = same_side(a,L)
    return a, d

def equatorial2ecliptical(a, d):
    e = 23.439168
    L = np.rad2deg(np.arctan(np.tan(np.deg2rad(a))*np.cos(np.deg2rad(e)) + np.tan(np.deg2rad(d))*np.sin(np.deg2rad(e))/np.cos(np.deg2rad(a))))
    B = np.rad2deg(np.arcsin(np.sin(np.deg2rad(d))*np.cos(np.deg2rad(e)) - np.cos(np.deg2rad(d))*np.sin(np.deg2rad(e))*np.sin(np.deg2rad(a))))
    L = same_side(L,a)
    return [B, L]

def linear_interp(x0, x1, y0, y1, xp):
    return (((xp - x0) / (x1 - x0)) * (y1 - y0)) + y0