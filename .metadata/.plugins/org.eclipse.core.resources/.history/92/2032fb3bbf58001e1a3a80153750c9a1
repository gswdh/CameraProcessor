#include "aamaths.h"

#include <float.h>

double aam_deg_wrap_360(double deg)
{
    double fResult = fmod(deg, 360);

    if (fResult < 0) fResult += 360;

    return fResult;
}

double aam_deg_wrap_9090(double deg)
{
    double fResult = aam_deg_wrap_360(deg);

    if (fResult > 270) return fResult - 360;

    if (fResult > 180) return 180 - fResult;

    if (fResult > 90) return 180 - fResult;

    return fResult;
}

double aam_abs_floor(double val)
{
    if (val >= 0.0) return floor(val);

    return ceil(val);
}

double aam_mod_day(double hours)
{
    if (hours < 0) hours += 24.0;

    return fmod(hours, 24);
}

double aam_mod_2pi(double angle)
{
    double b = angle / 360.0;
    double a = 360.0 * (b - aam_abs_floor(b));

    if (a < 0) a += 360.0;

    return a;
}

bool aam_sign(double n)
{
    if (n < 0) return false;

    return true;
}

double aam_same_side(double a, double r)
{
    if ((aam_sign(cos(DEG2RAD(a))) == aam_sign(cos(DEG2RAD(r)))) &&
        (aam_sign(sin(DEG2RAD(a))) == aam_sign(sin(DEG2RAD(r)))))
    {
        return fmod((a + 36000), 360);
    }

    return fmod((a + 36180), 360);
}

equatorial_t aam_ecliptical2equatorial(ecliptical_t coord)
{
    double l = coord.lambda;
    double b = coord.beta;
    double e = 23.439168;
    double a = RAD2DEG(atan(tan(DEG2RAD(l)) * cos(DEG2RAD(e)) - tan(DEG2RAD(b)) * sin(DEG2RAD(e)) / cos(DEG2RAD(l))));
    double d = RAD2DEG(asin(sin(DEG2RAD(b)) * cos(DEG2RAD(e)) + cos(DEG2RAD(b)) * sin(DEG2RAD(e)) * sin(DEG2RAD(l))));

    a = aam_same_side(a, l);
    equatorial_t val = { 0 };

    val.alpha = a;
    val.delta = d;
    return val;
}

ecliptical_t aam_equatorial2ecliptical(equatorial_t coord)
{
    double a = coord.alpha;
    double d = coord.delta;
    double e = 23.439168;
    double l = RAD2DEG(atan(tan(DEG2RAD(a)) * cos(DEG2RAD(e)) + tan(DEG2RAD(d)) * sin(DEG2RAD(e)) / cos(DEG2RAD(a))));
    double b = RAD2DEG(asin(sin(DEG2RAD(d)) * cos(DEG2RAD(e)) - cos(DEG2RAD(d)) * sin(DEG2RAD(e)) * sin(DEG2RAD(a))));

    l = aam_same_side(l, a);
    ecliptical_t val = { 0 };

    val.beta = b;
    val.lambda = l;
    return val;
}

double polynomial(double x, double * coefs, uint32_t coef_len)
{
    double y = 0;

    for (uint32_t i = 0; i < coef_len; i++)
    {
        y += coefs[i] * pow(x, coef_len - i - 1);
    }

    return y;
}

double aam_linear_interp(double x0, double x1, double y0, double y1, double xp)
{
    return (((xp - x0) / (x1 - x0)) * (y1 - y0)) + y0;
}

double aam_max(double * data, uint32_t len)
{
    double highest = DBL_MIN;

    for(uint32_t i = 0; i < len; i++)
    {
        if(data[i] > highest)
            highest = data[i];
    }

    return highest;
}

double aam_min(double * data, uint32_t len)
{
    double lowest = DBL_MAX;

    for(uint32_t i = 0; i < len; i++)
    {
        if(data[i] < lowest)
            lowest = data[i];
    }

    return lowest;
}
